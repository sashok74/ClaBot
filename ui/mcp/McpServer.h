//---------------------------------------------------------------------------
// McpServer.h — Universal MCP (Model Context Protocol) Server Framework
//
// A modern, reusable MCP server implementation with data-driven tool
// registration. Pure C++ with nlohmann::json - NO VCL dependencies.
//
// Adapted from DB_MCP project for ClaBot UI.
//---------------------------------------------------------------------------

#ifndef McpServerH
#define McpServerH

//---------------------------------------------------------------------------
#include <string>
#include <vector>
#include <map>
#include <memory>
#include <functional>
#include <mutex>
#include <stdexcept>
#include <sstream>
#include <algorithm>

#include "../../external/nlohmann/json.hpp"

namespace Mcp {

using json = nlohmann::json;

//---------------------------------------------------------------------------
// Error codes (JSON-RPC 2.0 standard)
//---------------------------------------------------------------------------
namespace ErrorCode {
    constexpr int ParseError = -32700;
    constexpr int InvalidRequest = -32600;
    constexpr int MethodNotFound = -32601;
    constexpr int InvalidParams = -32602;
    constexpr int InternalError = -32603;
    constexpr int ToolNotFound = -32001;
    constexpr int ToolExecutionError = -32002;
    constexpr int ProviderNotReady = -32003;
}

//---------------------------------------------------------------------------
// TMcpToolAnnotations — Tool behavior hints for clients
//---------------------------------------------------------------------------
struct TMcpToolAnnotations
{
    std::string Title;
    bool ReadOnlyHint = true;
    bool DestructiveHint = false;
    bool IdempotentHint = true;
    bool OpenWorldHint = false;

    json ToJson() const
    {
        json j;
        if (!Title.empty())
            j["title"] = Title;
        j["readOnlyHint"] = ReadOnlyHint;
        j["destructiveHint"] = DestructiveHint;
        j["idempotentHint"] = IdempotentHint;
        j["openWorldHint"] = OpenWorldHint;
        return j;
    }
};

//---------------------------------------------------------------------------
// TMcpSchemaProperty — Single property in JSON Schema
//---------------------------------------------------------------------------
struct TMcpSchemaProperty
{
    std::string Name;
    std::string Type = "string";
    std::string Description;
    bool Required = false;
    std::vector<std::string> EnumValues;

    TMcpSchemaProperty() = default;

    TMcpSchemaProperty(const std::string &name, const std::string &type,
        const std::string &desc, bool required = false)
        : Name(name), Type(type), Description(desc), Required(required) {}
};

//---------------------------------------------------------------------------
// TMcpToolSchema — JSON Schema for tool input
//---------------------------------------------------------------------------
class TMcpToolSchema
{
private:
    std::vector<TMcpSchemaProperty> FProperties;
    std::vector<std::string> FRequired;

public:
    TMcpToolSchema& AddString(const std::string &name, const std::string &desc,
        bool required = false)
    {
        FProperties.emplace_back(name, "string", desc, required);
        if (required) FRequired.push_back(name);
        return *this;
    }

    TMcpToolSchema& AddInteger(const std::string &name, const std::string &desc,
        bool required = false)
    {
        FProperties.emplace_back(name, "integer", desc, required);
        if (required) FRequired.push_back(name);
        return *this;
    }

    TMcpToolSchema& AddBoolean(const std::string &name, const std::string &desc,
        bool required = false)
    {
        FProperties.emplace_back(name, "boolean", desc, required);
        if (required) FRequired.push_back(name);
        return *this;
    }

    TMcpToolSchema& AddEnum(const std::string &name, const std::string &desc,
        const std::vector<std::string> &values, bool required = false)
    {
        TMcpSchemaProperty prop(name, "string", desc, required);
        prop.EnumValues = values;
        FProperties.push_back(prop);
        if (required) FRequired.push_back(name);
        return *this;
    }

    json ToJson() const
    {
        json schema;
        schema["type"] = "object";

        json props = json::object();
        for (const auto &p : FProperties)
        {
            json propDef;
            propDef["type"] = p.Type;
            if (!p.Description.empty())
                propDef["description"] = p.Description;
            if (!p.EnumValues.empty())
                propDef["enum"] = p.EnumValues;
            props[p.Name] = propDef;
        }
        schema["properties"] = props;

        if (!FRequired.empty())
            schema["required"] = FRequired;

        return schema;
    }
};

//---------------------------------------------------------------------------
// TMcpToolContext — Execution context passed to tools
//---------------------------------------------------------------------------
class TMcpToolContext
{
public:
    TMcpToolContext() = default;
};

//---------------------------------------------------------------------------
// TMcpToolResult — Result from tool execution
//---------------------------------------------------------------------------
struct TMcpToolResult
{
    json Content;
    bool IsError = false;
    std::string ErrorMessage;

    static TMcpToolResult Success(const json &content)
    {
        TMcpToolResult r;
        r.Content = content;
        r.IsError = false;
        return r;
    }

    static TMcpToolResult Success(const std::string &jsonString)
    {
        TMcpToolResult r;
        try {
            r.Content = json::parse(jsonString);
        } catch (...) {
            r.Content = jsonString;
        }
        r.IsError = false;
        return r;
    }

    static TMcpToolResult Error(const std::string &message)
    {
        TMcpToolResult r;
        r.Content = json{{"error", message}};
        r.IsError = true;
        r.ErrorMessage = message;
        return r;
    }
};

//---------------------------------------------------------------------------
// IMcpTool — Abstract interface for MCP tools
//---------------------------------------------------------------------------
class IMcpTool
{
public:
    virtual ~IMcpTool() = default;

    virtual std::string GetName() const = 0;
    virtual std::string GetDescription() const = 0;
    virtual TMcpToolSchema GetInputSchema() const = 0;

    virtual TMcpToolAnnotations GetAnnotations() const
    {
        TMcpToolAnnotations ann;
        ann.Title = GetName();
        return ann;
    }

    virtual TMcpToolResult Execute(const json &args, TMcpToolContext &context) = 0;

    json ToToolJson() const
    {
        json tool;
        tool["name"] = GetName();
        tool["description"] = GetDescription();
        tool["inputSchema"] = GetInputSchema().ToJson();
        tool["annotations"] = GetAnnotations().ToJson();
        return tool;
    }
};

//---------------------------------------------------------------------------
// TMcpToolBase — Base class for tools with common functionality
//---------------------------------------------------------------------------
class TMcpToolBase : public IMcpTool
{
public:
    static std::string GetString(const json &args, const std::string &key,
        const std::string &defaultValue = "")
    {
        if (args.is_null() || !args.contains(key))
            return defaultValue;
        const auto &val = args[key];
        if (val.is_null())
            return defaultValue;
        if (val.is_string())
            return val.get<std::string>();
        return val.dump();
    }

    static int GetInt(const json &args, const std::string &key, int defaultValue = 0)
    {
        if (args.is_null() || !args.contains(key))
            return defaultValue;
        const auto &val = args[key];
        if (val.is_null())
            return defaultValue;
        if (val.is_number_integer())
            return val.get<int>();
        if (val.is_string()) {
            try { return std::stoi(val.get<std::string>()); }
            catch (...) { return defaultValue; }
        }
        return defaultValue;
    }

    static bool GetBool(const json &args, const std::string &key, bool defaultValue = false)
    {
        if (args.is_null() || !args.contains(key))
            return defaultValue;
        const auto &val = args[key];
        if (val.is_null())
            return defaultValue;
        if (val.is_boolean())
            return val.get<bool>();
        if (val.is_string()) {
            std::string s = val.get<std::string>();
            std::transform(s.begin(), s.end(), s.begin(), ::tolower);
            return (s == "true" || s == "1" || s == "yes");
        }
        return defaultValue;
    }
};

//---------------------------------------------------------------------------
// TMcpLambdaTool — Tool created from lambda/function
//---------------------------------------------------------------------------
class TMcpLambdaTool : public TMcpToolBase
{
public:
    using ExecuteFunc = std::function<TMcpToolResult(const json&, TMcpToolContext&)>;

private:
    std::string FName;
    std::string FDescription;
    TMcpToolSchema FSchema;
    TMcpToolAnnotations FAnnotations;
    ExecuteFunc FExecute;

public:
    TMcpLambdaTool(const std::string &name, const std::string &description,
        const TMcpToolSchema &schema, ExecuteFunc executeFunc)
        : FName(name)
        , FDescription(description)
        , FSchema(schema)
        , FExecute(std::move(executeFunc))
    {
        FAnnotations.Title = name;
    }

    TMcpLambdaTool& WithAnnotations(const TMcpToolAnnotations &ann)
    {
        FAnnotations = ann;
        return *this;
    }

    std::string GetName() const override { return FName; }
    std::string GetDescription() const override { return FDescription; }
    TMcpToolSchema GetInputSchema() const override { return FSchema; }
    TMcpToolAnnotations GetAnnotations() const override { return FAnnotations; }

    TMcpToolResult Execute(const json &args, TMcpToolContext &context) override
    {
        if (FExecute)
            return FExecute(args, context);
        return TMcpToolResult::Error("No execute function defined");
    }
};

//---------------------------------------------------------------------------
// TMcpToolRegistry — Central registry for MCP tools
//---------------------------------------------------------------------------
class TMcpToolRegistry
{
private:
    std::map<std::string, std::unique_ptr<IMcpTool>> FTools;
    mutable std::mutex FMutex;

public:
    TMcpToolRegistry() = default;

    TMcpToolRegistry(const TMcpToolRegistry&) = delete;
    TMcpToolRegistry& operator=(const TMcpToolRegistry&) = delete;

    void Register(std::unique_ptr<IMcpTool> tool)
    {
        if (!tool) return;
        std::lock_guard<std::mutex> lock(FMutex);
        std::string name = tool->GetName();
        FTools[name] = std::move(tool);
    }

    void RegisterLambda(const std::string &name, const std::string &description,
        const TMcpToolSchema &schema, TMcpLambdaTool::ExecuteFunc func)
    {
        Register(std::make_unique<TMcpLambdaTool>(name, description, schema, std::move(func)));
    }

    IMcpTool* Get(const std::string &name) const
    {
        std::lock_guard<std::mutex> lock(FMutex);
        auto it = FTools.find(name);
        return (it != FTools.end()) ? it->second.get() : nullptr;
    }

    json GenerateToolsListJson() const
    {
        std::lock_guard<std::mutex> lock(FMutex);
        json toolsArray = json::array();
        for (const auto &pair : FTools)
            toolsArray.push_back(pair.second->ToToolJson());
        return json{{"tools", toolsArray}};
    }
};

//---------------------------------------------------------------------------
// TMcpServerInfo — Server identification
//---------------------------------------------------------------------------
struct TMcpServerInfo
{
    std::string Name = "McpServer";
    std::string Version = "1.0.0";

    TMcpServerInfo() = default;
    TMcpServerInfo(const std::string &name, const std::string &version)
        : Name(name), Version(version) {}

    json ToJson() const
    {
        json j;
        j["name"] = Name;
        j["version"] = Version;
        return j;
    }
};

//---------------------------------------------------------------------------
// TMcpServerCapabilities — Server capabilities
//---------------------------------------------------------------------------
struct TMcpServerCapabilities
{
    bool ToolsListChanged = false;

    json ToJson() const
    {
        json j;
        j["tools"] = json{{"listChanged", ToolsListChanged}};
        return j;
    }
};

//---------------------------------------------------------------------------
// Event handlers (callbacks)
//---------------------------------------------------------------------------
using TOnToolExecuted = std::function<void(const std::string &toolName, bool success,
    const std::string &errorMessage)>;
using TOnRequestReceived = std::function<void(const std::string &method,
    const std::string &requestJson)>;
using TOnResponseSent = std::function<void(const std::string &responseJson)>;

//---------------------------------------------------------------------------
// TMcpServer — Main MCP server class
//---------------------------------------------------------------------------
class TMcpServer
{
private:
    TMcpServerInfo FServerInfo;
    TMcpServerCapabilities FCapabilities;
    std::string FProtocolVersion = "2024-11-05";
    std::unique_ptr<TMcpToolRegistry> FToolRegistry;
    TMcpToolContext FContext;

    TOnToolExecuted FOnToolExecuted;
    TOnRequestReceived FOnRequestReceived;
    TOnResponseSent FOnResponseSent;

    mutable std::mutex FMutex;

public:
    explicit TMcpServer(const std::string &name = "McpServer",
        const std::string &version = "1.0.0")
        : FServerInfo(name, version)
        , FToolRegistry(std::make_unique<TMcpToolRegistry>())
    {}

    TMcpServer(const TMcpServer&) = delete;
    TMcpServer& operator=(const TMcpServer&) = delete;

    TMcpServer(TMcpServer&&) = default;
    TMcpServer& operator=(TMcpServer&&) = default;

    void RegisterLambda(const std::string &name, const std::string &description,
        const TMcpToolSchema &schema, TMcpLambdaTool::ExecuteFunc func)
    {
        FToolRegistry->RegisterLambda(name, description, schema, std::move(func));
    }

    void SetOnToolExecuted(TOnToolExecuted handler) { FOnToolExecuted = std::move(handler); }
    void SetOnRequestReceived(TOnRequestReceived handler) { FOnRequestReceived = std::move(handler); }
    void SetOnResponseSent(TOnResponseSent handler) { FOnResponseSent = std::move(handler); }

    std::string HandleRequest(const std::string &requestJson)
    {
        try
        {
            json root = json::parse(requestJson);
            if (root.is_array())
                return EmitResponse(HandleBatchRequestInternal(root));
            return EmitResponse(HandleRequestInternal(root, requestJson));
        }
        catch (const json::parse_error &e)
        {
            if (FOnRequestReceived)
                FOnRequestReceived("parse_error", requestJson);
            return EmitResponse(MakeError("null", ErrorCode::ParseError,
                std::string("Parse error: ") + e.what()));
        }
    }

    std::string HandleBatchRequest(const std::string &requestJson)
    {
        try
        {
            json val = json::parse(requestJson);

            if (!val.is_array())
                return HandleRequest(requestJson);

            return EmitResponse(HandleBatchRequestInternal(val));
        }
        catch (const json::parse_error &e)
        {
            if (FOnRequestReceived)
                FOnRequestReceived("parse_error", requestJson);
            return EmitResponse(MakeError("null", ErrorCode::ParseError,
                std::string("Parse error: ") + e.what()));
        }
    }

private:
    std::string EmitResponse(const std::string &responseJson)
    {
        if (!responseJson.empty() && FOnResponseSent)
            FOnResponseSent(responseJson);
        return responseJson;
    }

    std::string HandleBatchRequestInternal(const json &batch)
    {
        if (!batch.is_array())
            return MakeError("null", ErrorCode::InvalidRequest, "Invalid JSON-RPC batch");

        json responses = json::array();
        for (const auto &req : batch)
        {
            std::string resp = HandleRequestInternal(req, req.dump());
            if (!resp.empty())
                responses.push_back(json::parse(resp));
        }

        if (responses.empty())
            return "";
        return responses.dump();
    }

    std::string HandleRequestInternal(const json &reqJson, const std::string &rawJson)
    {
        if (!reqJson.is_object())
        {
            if (FOnRequestReceived)
                FOnRequestReceived("invalid_request", rawJson);
            return MakeError("null", ErrorCode::InvalidRequest, "Invalid JSON-RPC request");
        }

        std::string id;
        bool isNotification = true;
        if (reqJson.contains("id"))
        {
            id = reqJson["id"].dump();
            if (!reqJson["id"].is_null())
                isNotification = false;
        }

        if (reqJson.contains("jsonrpc"))
        {
            if (!reqJson["jsonrpc"].is_string() ||
                reqJson["jsonrpc"].get<std::string>() != "2.0")
            {
                if (FOnRequestReceived)
                    FOnRequestReceived("invalid_request", rawJson);
                return MakeError(id, ErrorCode::InvalidRequest,
                    "Invalid 'jsonrpc' version");
            }
        }

        if (!reqJson.contains("method") || !reqJson["method"].is_string())
        {
            if (FOnRequestReceived)
                FOnRequestReceived("invalid_request", rawJson);
            return MakeError(id, ErrorCode::InvalidRequest, "Missing 'method'");
        }

        std::string method = reqJson["method"].get<std::string>();
        if (FOnRequestReceived)
            FOnRequestReceived(method, rawJson);

        std::string response;
        if (method == "initialize")
            response = HandleInitialize(reqJson, id);
        else if (method == "tools/list")
            response = HandleToolsList(reqJson, id);
        else if (method == "tools/call")
            response = HandleToolsCall(reqJson, id);
        else if (method == "ping")
            response = HandlePing(id);
        else
            response = MakeError(id, ErrorCode::MethodNotFound, "Unknown method: " + method);

        if (isNotification)
            return "";
        return response;
    }

    std::string HandleInitialize(const json &reqJson, const std::string &id)
    {
        json result;
        result["protocolVersion"] = FProtocolVersion;
        result["capabilities"] = FCapabilities.ToJson();
        result["serverInfo"] = FServerInfo.ToJson();
        return MakeResponse(id, result);
    }

    std::string HandleToolsList(const json &reqJson, const std::string &id)
    {
        return MakeResponse(id, FToolRegistry->GenerateToolsListJson());
    }

    std::string HandleToolsCall(const json &reqJson, const std::string &id)
    {
        if (!reqJson.contains("params") || reqJson["params"].is_null())
            return MakeError(id, ErrorCode::InvalidParams, "Missing 'params'");

        const json &params = reqJson["params"];
        if (!params.is_object())
            return MakeError(id, ErrorCode::InvalidParams, "Invalid 'params'");

        if (!params.contains("name") || !params["name"].is_string())
            return MakeError(id, ErrorCode::InvalidParams, "Missing 'params.name'");

        std::string toolName = params["name"].get<std::string>();

        json args = json::object();
        if (params.contains("arguments") && !params["arguments"].is_null())
            args = params["arguments"];

        IMcpTool *tool = FToolRegistry->Get(toolName);
        if (!tool)
        {
            if (FOnToolExecuted)
                FOnToolExecuted(toolName, false, "Tool not found");
            return MakeError(id, ErrorCode::ToolNotFound, "Unknown tool: " + toolName);
        }

        TMcpToolResult result;
        try
        {
            result = tool->Execute(args, FContext);
        }
        catch (const std::exception &e)
        {
            result = TMcpToolResult::Error(std::string("Tool execution failed: ") + e.what());
        }

        if (FOnToolExecuted)
            FOnToolExecuted(toolName, !result.IsError, result.ErrorMessage);

        json mcpResult = BuildToolResponse(result);
        return MakeResponse(id, mcpResult);
    }

    std::string HandlePing(const std::string &id)
    {
        return MakeResponse(id, json{{"status", "ok"}});
    }

    static json BuildToolResponse(const TMcpToolResult &result)
    {
        std::string contentStr;
        if (result.Content.is_string())
            contentStr = result.Content.get<std::string>();
        else
            contentStr = result.Content.dump();

        json response;
        response["content"] = json::array({
            json{{"type", "text"}, {"text", contentStr}}
        });

        if (result.IsError)
            response["isError"] = true;

        return response;
    }

    static std::string MakeResponse(const std::string &id, const json &result)
    {
        json response;
        response["jsonrpc"] = "2.0";
        response["id"] = json::parse(id.empty() ? "null" : id);
        response["result"] = result;
        return response.dump();
    }

    static std::string MakeError(const std::string &id, int code, const std::string &message)
    {
        json response;
        response["jsonrpc"] = "2.0";
        response["id"] = json::parse(id.empty() ? "null" : id);
        response["error"] = json{{"code", code}, {"message", message}};
        return response.dump();
    }
};

} // namespace Mcp

//---------------------------------------------------------------------------
#endif // McpServerH
